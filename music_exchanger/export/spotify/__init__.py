import logging

from spotipy import Spotify, SpotifyOAuth

from music_exchanger.export.utils import polish_song_name
from music_exchanger.settings import SpotifyConfig, UNCLASSIFIED_SONG_KEY_NAME
from tqdm import tqdm

logger = logging.getLogger(__name__)


class SpotifyExportClient(Spotify):
    def __init__(self, *args, **kwargs):
        self.tracks_found = set()
        self.tracks_not_found = set()
        self.tracks_with_exception = dict()

        config = SpotifyConfig()

        auth_manager = SpotifyOAuth(
            client_id=config.client_id,
            client_secret=config.client_secret,
            redirect_uri=config.redirect_uri,
        )
        super().__init__(auth_manager=auth_manager, *args, **kwargs)

    def search_tracks(self, data):
        for performer, songs_set in tqdm(
            data.items(),
            desc="Searching tracks of performers",
            unit="performer",
        ):
            query_performer = (
                f"artist:{performer}" if performer != UNCLASSIFIED_SONG_KEY_NAME else ""
            )

            for song_name in tqdm(
                songs_set,
                desc=f"Searching tracks of {performer}",
                unit="track",
            ):
                track_title = polish_song_name(performer, song_name)
                query_track_title = f"track:{track_title}"

                try:
                    results = self.search(
                        q=f"{query_track_title} {query_performer}",
                        type="track",
                        limit=1,
                    )
                except Exception as e:
                    self.tracks_with_exception[track_title] = e
                    logger.warning(
                        f"Search for track '{track_title}' was aborted due to exception: {e}"
                    )
                    continue

                if tracks := results["tracks"]["items"]:
                    self.tracks_found.add(tracks[0]["id"])
                else:
                    self.tracks_not_found.add(track_title)

    def safe_add_tracks(self, playlist_id, track_ids):
        """Spotipy allows only 100 ids per request"""

        track_ids = list(track_ids)

        for i in tqdm(
            range(0, len(track_ids), 100),
            desc="Adding tracks to the playlist",
        ):
            batch = track_ids[i : i + 100]
            self.playlist_add_items(playlist_id, batch)

    def export(
        self,
        data: dict[str, set[str]],
        playlist_name: str = "exportPlaylist",
        description: str = "Playlist generated by moveSongsFromPirate",
        **kwargs,
    ):
        self.search_tracks(data)

        logger.info(
            f"{self.tracks_found} – tracks found; "
            f"{self.tracks_not_found} – tracks not found; "
            f"{len(self.tracks_with_exception)} – track searches raised an exception"
        )

        playlist = self.user_playlist_create(
            user=self.me()["id"],
            name=playlist_name,
            description=description,
            **kwargs,
        )

        self.safe_add_tracks(playlist["id"], self.tracks_found)

        logger.info(f"✅Created playlist: {playlist['external_urls']['spotify']}")
